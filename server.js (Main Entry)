/**
 * BaristaBot Pro Backend Server
 * Powered by Dennis Kathurima
 * 
 * Features:
 * - WebSocket real-time order updates
 * - M-Pesa Daraja API integration
 * - Web3 payment processing (ETH, MATIC, SOL)
 * - POS system webhooks
 */

require('dotenv').config();
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const WebSocket = require('ws');
const http = require('http');
const winston = require('winston');

// Winston logger setup
const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.Console(),
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
    new winston.transports.File({ filename: 'combined.log' })
  ]
});

const app = express();
const server = http.createServer(app);

// WebSocket server for real-time updates
const wss = new WebSocket.Server({ 
  server,
  path: '/ws',
  perMessageDeflate: false
});

// Store connected clients
const clients = new Map();

wss.on('connection', (ws, req) => {
  const clientId = Date.now();
  clients.set(clientId, { ws, orders: [] });
  
  logger.info(`New WebSocket client connected: ${clientId}`);
  
  ws.send(JSON.stringify({
    type: 'CONNECTION_ESTABLISHED',
    clientId,
    timestamp: new Date().toISOString()
  }));

  ws.on('message', (data) => {
    try {
      const message = JSON.parse(data);
      handleClientMessage(clientId, message);
    } catch (err) {
      logger.error('Invalid WebSocket message:', err);
    }
  });

  ws.on('close', () => {
    logger.info(`Client disconnected: ${clientId}`);
    clients.delete(clientId);
  });

  ws.on('error', (err) => {
    logger.error(`WebSocket error for client ${clientId}:`, err);
  });
});

// Broadcast to specific order subscribers or all clients
const broadcast = (data, orderId = null) => {
  const message = JSON.stringify(data);
  
  clients.forEach((client, id) => {
    if (orderId && !client.orders.includes(orderId)) return;
    
    if (client.ws.readyState === WebSocket.OPEN) {
      client.ws.send(message);
    }
  });
  
  logger.info(`Broadcasted ${data.type} to ${clients.size} clients`);
};

// Handle client messages (subscribe to order updates)
const handleClientMessage = (clientId, message) => {
  const client = clients.get(clientId);
  if (!client) return;

  switch (message.type) {
    case 'SUBSCRIBE_ORDER':
      client.orders.push(message.orderId);
      logger.info(`Client ${clientId} subscribed to order ${message.orderId}`);
      break;
    case 'UNSUBSCRIBE_ORDER':
      client.orders = client.orders.filter(id => id !== message.orderId);
      break;
    default:
      logger.warn(`Unknown message type: ${message.type}`);
  }
};

// Security middleware
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      connectSrc: ["'self'", "https://*.safaricom.co.ke", "wss://*"]
    }
  }
}));

app.use(cors({
  origin: process.env.FRONTEND_URL || 'https://denniskathurima.github.io',
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization']
}));

// Rate limiting
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100,
  message: { error: 'Too many requests, please try again later' },
  standardHeaders: true,
  legacyHeaders: false
});
app.use(limiter);

// Stricter limit for M-Pesa (costs money per request)
const mpesaLimiter = rateLimit({
  windowMs: 60 * 1000, // 1 minute
  max: 5,
  message: { error: 'M-Pesa requests limited to 5 per minute' }
});

app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true }));

// Request logging
app.use((req, res, next) => {
  logger.info(`${req.method} ${req.path} - ${req.ip}`);
  next();
});

// Health check endpoint
app.get('/health', (req, res) => {
  res.json({
    status: 'healthy',
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    websocketClients: clients.size,
    environment: process.env.NODE_ENV
  });
});

// API Routes
app.use('/api/mpesa', mpesaLimiter, require('./src/routes/mpesa')(broadcast));
app.use('/api/orders', require('./src/routes/orders')(broadcast));
app.use('/api/web3', require('./src/routes/web3'));
app.use('/api/pos', require('./src/routes/pos')(broadcast));

// Error handling
app.use((err, req, res, next) => {
  logger.error('Unhandled error:', err);
  res.status(500).json({ 
    error: 'Internal server error',
    requestId: req.id 
  });
});

// 404 handler
app.use((req, res) => {
  res.status(404).json({ error: 'Endpoint not found' });
});

const PORT = process.env.PORT || 3000;
server.listen(PORT, () => {
  logger.info(`
  â˜• BARISTABOT PRO BACKEND â˜•
  ===========================
  Server running on port ${PORT}
  Environment: ${process.env.NODE_ENV || 'development'}
  WebSocket: ws://localhost:${PORT}/ws
  M-Pesa: ${process.env.MPESA_ENVIRONMENT || 'sandbox'}
  Frontend: ${process.env.FRONTEND_URL}
  
  Ready for Nairobi & Global! ðŸš€
  `);
});

module.exports = { broadcast, logger };
