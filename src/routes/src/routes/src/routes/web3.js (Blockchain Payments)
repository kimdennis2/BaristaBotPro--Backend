/**
 * Web3 Payment Routes
 * Handles MetaMask (Ethereum/Polygon) and Phantom (Solana) transactions
 */

const express = require('express');
const { Web3 } = require('web3');
const solanaWeb3 = require('@solana/web3.js');

const router = express.Router();

// Initialize connections
const ethConnection = new Web3(process.env.ETHEREUM_RPC_URL || 'https://polygon-rpc.com');
const solConnection = new solanaWeb3.Connection(
  process.env.SOLANA_RPC_URL || 'https://api.mainnet-beta.solana.com'
);

// Verify Ethereum transaction
router.post('/verify-eth', async (req, res) => {
  try {
    const { txHash, orderId, expectedAmount } = req.body;

    if (!txHash || !txHash.startsWith('0x')) {
      return res.status(400).json({ success: false, error: 'Invalid transaction hash' });
    }

    // Get transaction receipt
    const receipt = await ethConnection.eth.getTransactionReceipt(txHash);
    
    if (!receipt) {
      return res.status(404).json({ 
        success: false, 
        error: 'Transaction not found or still pending',
        status: 'pending'
      });
    }

    if (!receipt.status) {
      return res.status(400).json({
        success: false,
        error: 'Transaction failed on-chain',
        status: 'failed'
      });
    }

    // Get transaction details
    const tx = await ethConnection.eth.getTransaction(txHash);
    const value = ethConnection.utils.fromWei(tx.value, 'ether');
    
    // Verify recipient is your address
    const yourAddress = process.env.COFFEE_SHOP_ETH_ADDRESS?.toLowerCase();
    if (tx.to.toLowerCase() !== yourAddress) {
      return res.status(400).json({
        success: false,
        error: 'Transaction sent to wrong address'
      });
    }

    // Convert expected amount (KES to ETH approx)
    // In production, use Chainlink price feeds
    const ethPriceUsd = 2200; // Mock price - use real oracle
    const kesToUsd = 0.0077; // KES to USD rate
    const expectedEth = (expectedAmount * kesToUsd) / ethPriceUsd;
    
    // Allow 5% slippage for gas fluctuations
    const received = parseFloat(value);
    const minimumExpected = expectedEth * 0.95;

    if (received < minimumExpected) {
      return res.status(400).json({
        success: false,
        error: `Insufficient amount. Expected ~${expectedEth.toFixed(6)} ETH, received ${received} ETH`
      });
    }

    res.json({
      success: true,
      verified: true,
      txHash,
      from: tx.from,
      to: tx.to,
      value: received,
      currency: 'ETH',
      network: 'Polygon',
      blockNumber: receipt.blockNumber,
      gasUsed: receipt.gasUsed,
      confirmations: receipt.confirmations || 0
    });

  } catch (error) {
    console.error('ETH Verification Error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to verify transaction',
      details: error.message
    });
  }
});

// Verify Solana transaction
router.post('/verify-sol', async (req, res) => {
  try {
    const { signature, orderId, expectedAmount } = req.body;

    if (!signature) {
      return res.status(400).json({ success: false, error: 'Signature required' });
    }

    // Get transaction
    const tx = await solConnection.getTransaction(signature, {
      commitment: 'confirmed'
    });

    if (!tx) {
      return res.status(404).json({
        success: false,
        error: 'Transaction not found',
        status: 'pending'
      });
    }

    if (tx.meta.err) {
      return res.status(400).json({
        success: false,
        error: 'Transaction failed on-chain',
        status: 'failed',
        details: tx.meta.err
      });
    }

    // Parse transfer amount (SOL has 9 decimals)
    const postBalance = tx.meta.postBalances[1] || 0;
    const preBalance = tx.meta.preBalances[1] || 0;
    const lamportsReceived = postBalance - preBalance;
    const solReceived = lamportsReceived / solanaWeb3.LAMPORTS_PER_SOL;

    // Verify recipient
    const accountKeys = tx.transaction.message.accountKeys;
    const recipient = accountKeys[1].toString();
    
    if (recipient !== process.env.COFFEE_SHOP_SOL_ADDRESS) {
      return res.status(400).json({
        success: false,
        error: 'Transaction sent to wrong address'
      });
    }

    // Check amount (mock conversion)
    const solPriceUsd = 95; // Mock SOL price
    const kesToUsd = 0.0077;
    const expectedSol = (expectedAmount * kesToUsd) / solPriceUsd;

    if (solReceived < expectedSol * 0.95) {
      return res.status(400).json({
        success: false,
        error: `Insufficient amount. Expected ~${expectedSol.toFixed(4)} SOL, received ${solReceived} SOL`
      });
    }

    res.json({
      success: true,
      verified: true,
      signature,
      sender: accountKeys[0].toString(),
      recipient,
      amount: solReceived,
      currency: 'SOL',
      network: 'Solana',
      slot: tx.slot,
      confirmations: tx.confirmations || 0,
      timestamp: tx.blockTime ? new Date(tx.blockTime * 1000).toISOString() : null
    });

  } catch (error) {
    console.error('SOL Verification Error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to verify Solana transaction',
      details: error.message
    });
  }
});

// Get wallet balance (for monitoring)
router.get('/balance/:chain', async (req, res) => {
  try {
    const { chain } = req.params;
    
    if (chain === 'eth' || chain === 'polygon') {
      const address = process.env.COFFEE_SHOP_ETH_ADDRESS;
      const balance = await ethConnection.eth.getBalance(address);
      const ethBalance = ethConnection.utils.fromWei(balance, 'ether');
      
      res.json({
        chain: 'polygon',
        address,
        balance: ethBalance,
        currency: 'MATIC'
      });
      
    } else if (chain === 'sol') {
      const address = process.env.COFFEE_SHOP_SOL_ADDRESS;
      const publicKey = new solanaWeb3.PublicKey(address);
      const balance = await solConnection.getBalance(publicKey);
      
      res.json({
        chain: 'solana',
        address,
        balance: balance / solanaWeb3.LAMPORTS_PER_SOL,
        currency: 'SOL'
      });
    } else {
      res.status(400).json({ error: 'Invalid chain. Use eth, polygon, or sol' });
    }
    
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

module.exports = router;
